* # 01 算法时间复杂度 -- 红果沿7-2

  

  ## 1.定义

  * 算法时间复杂度是指算法中基本操作的执行次数

  

  ## 1.2 计算方法

  

  ### 1.2.1 计算时间复杂度方法

  * 找出算法的基本操作

  * 确定算法基本操作的执行次数

  * 找出T(n)的同数量级

    * 算法中的语句执行次数称为语句频度或时间频度，记为T(n)
    * 同数量级
      * 1，log~2~n，n，nlog~2~n，n^2^,n^3^,2^n^,n!

  * 找出后f(n)=该数量级

  * 若T(n)/f(n)求极限可得到一常数c，则时间复杂度T(n)=O(f(n))

  * 总结：O( )就是对里面的多项式进行高阶无穷小计算，所以多项式T(n)进行O( )计算后只剩下影响最大的那一项被保留

    

  

  ## 1.3 注意

  * 在填空题中，要求填写时间复杂度时，一定要写上O，不能只填写一个表达式

  

  ## 1.4 常见的时间复杂度算法比较

  * $$
    O(1)<=O(log_2n)<=O(n)<=O(nlog_2n)<=O(n^2)<=O(n^3)<=\\……<=O(n^k)<=O(2^n)<=O(n!)<=O(n^n)
    $$

  


  # 02 王道课件 -- 算法时间复杂度

  

  ## 2.1 算法时间复杂度

  * 算法时间复杂度：时间开销T(n)与问题规模n的关系（T表示“time”）

  

  ## 2.2 时间开销与问题规模n的关系

  * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202306282158229.png" alt="image-20230628215818090" style="zoom:50%;" />

  

  ## 2.3 大O

  * 大O表示“同阶”，同等数量级。即：当n→∞时，二者之比为常数

  * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202306290925455.png" alt="image-20230629092503301" style="zoom: 80%;" />

  * 只考虑阶数高的部分
  * 问题规模足够大时，常数项系数可以忽略

  

  ## 2.4 加法规则 乘法规则

  * 加法规则：多项相加只保留最高阶的项且系数为1
  * 乘法规则：多项相乘都保留
  * ![image-20230629094055659](https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202306290940800.png)

  * $$
    T_3(n)=n^3+n^2log_2n=O(n^3)+O(n^2log_2n)=O(n^3)
    $$

    

  ## 2.5 算法时间复杂度阶数比较

  * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202306290951568.png" alt="image-20230629095129376" style="zoom:50%;" />

  

  ## 2.5.1 log~a~n的导数 对数导数

  * $$
    (log_an)'=\frac{1}{nlna}
    $$

  

  ## 2.5.2 a^n^的导数 指数导数

  * $$
    (a^n)'=a^nlna
    $$

  

  ## 2.5.3 算法时间复杂度阶数口诀

  * 常对幂指阶

  * $$
    O(1)<O(log_2n)<O(n)<O(nlog_2n)<O(n^2)<O(n^3)……<O(2^n)<O(n!)<O(n^n)
    $$

  

  ## 2.5.4 算法时间复杂度只考虑阶数，用大O记法表示

  

  ## 2.5.5 顺序执行的代码只会影响常数项，可以忽略

  

  ## 2.5.6 只需挑循环中的一个基本操作分析它的执行次数与n的关系即可

  

  ## 2.5.7 如果有多层嵌套循环，只需关注最深层循环循环了几次

  * 考虑最深层循环的循环次数与n的关系

  

  ## 2.5.8 指数递增型爱你

  ~~~C
  void LoveYou(int n)
  {
      int i = 1;
      while(i<=n)
      {
          i=i*2;
          printf("I love you %d\n",i);
      }
      print("I love you more than %d\n",i);
  }
  ~~~

  * 计算上述算法的时间复杂度T(n)
    * 设最深层循环的语句频度（总循环次数）为x
    * 由循环条件可知，循环结束时正好满足2^x^>n
    * x=log~2~n+1
    * T(n)=O(x)=O(log~2~n)

  

  ## 2.6 break;

  * The break statement is almost always used with `if……else` statement inside the loop.
  * How break statement works?
    * <img src="https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202307010422815.png" alt="image-20230701042230684" style="zoom: 67%;" />

  * The break statement doesn't exist the if statement but the loop statement.

  

  ## 2.7 搜索数字型我爱你

  ~~~C
  void LoveYou(int flag[],int n)
  {
      for(int i=0;i<n;i++)
      {
          if(n==flag[i])
          {
              printf("I love you %d\n",n);
              break; //找到后立即跳出循环
          }
      }
  }
  
  int flag[n]={1,……，n};//flag数组中乱序存放了1~n这些数
  LoveYou(flag,n);
  ~~~

  * 计算算法复杂度T(n)

  * 最好情况：元素n在第一个位置 -- 最好时间复杂度T(n)=O(1)

  * 最坏情况：元素n在最后一个位置 -- 最好时间复杂度T(n)=O(n)

  * 平均情况：假设元素n在任意一个位置的概率相同为1/n -- 平均时间复杂度T（n）= O（n）

  * 很多算法执行时间与输入的数据有关

    * $$
      期望：EX=\sum_{i=1}^{n}a_ip_i
      $$

    * 循环次数

      * $$
        x=(1+2+……+n)\cdot\frac{1}{n}=\frac{(1+n)\cdot n}{2}\cdot\frac{1}{n}=\frac{1+n}{2}
        $$

    * 时间复杂度

      * $$
        T(n)=O(x)=O(n)
        $$

  

  ## 2.8 最好 平均 最坏时间复杂度

  * 最坏时间复杂度：最坏情况下算法的时间复杂度
  * 平均时间复杂度：所有输入示例等概率出现的情况下，算法的期望运行时间
  * 最好时间复杂度：最好情况下算法的时间复杂度

  

  ## 2.9 总结

  * ![image-20230701052611513](https://cvp.oss-cn-shanghai.aliyuncs.com/picgo/202307010526734.png)

* 算法的性能问题只有在n很大时才会暴露出来

